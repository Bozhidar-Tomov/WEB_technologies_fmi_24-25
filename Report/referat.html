<!DOCTYPE html>
<html lang="bg">
  <head>
    <meta charset="UTF-8" />
    <title>Оценка на JavaScript приложенията</title>
    <link rel="stylesheet" href="css/style.css" />
  </head>
  <body>
    <header id="header">
      <h1>Оценка на JavaScript приложенията</h1>
      <nav id="navbuttons">
        <button onclick="openNav()">Съдържание</button>
        <button onclick="scrollToSection('resources')">Източници</button>
      </nav>
    </header>

    <aside id="mySidenav" class="sidenav" tabindex="-1">
      <button class="closebtn" onclick="closeNav()" aria-label="Close Navigation">&times;</button>
      <nav>
        <ul>
          <li><a href="#loading" tabindex="0">Фактори, забавящи зареждането на уеб страници</a></li>
          <li><a href="#js-cost" tabindex="0">Цената на зареждането на JavaScript</a></li>
          <li>
            <a href="#js-measurement" tabindex="0"
              >Измерване на времето и ресурсите за парсване и компилиране на JavaScript код</a
            >
          </li>
          <li><a href="#networking" tabindex="0">Влияние на мрежовия трафик</a></li>
          <li>
            <a href="#optimizations" tabindex="0">Методи за оптимизиране</a>
            <ul>
              <li><a href="#caching" tabindex="0">Кеширане</a></li>
              <li><a href="#streaming" tabindex="0">Script Streaming</a></li>
              <li>
                <a href="#recompilation" tabindex="0">Предварителна компилация</a>
              </li>
            </ul>
          </li>
        </ul>
      </nav>
    </aside>
    <main>
      <section id="loading">
        <h2>Фактори, забавящи зареждането на уеб страници</h2>
        <article class="content">
          <p>
            Зареждането на уеб страници може да бъде забавено от различни фактори, включително
            големи JavaScript файлове, които изискват време за изтегляне, парсване и изпълнение.
            Това е особено критично при мобилни устройства с ограничени ресурси, където хардуерните
            ограничения като по-бавни процесори и по-малко памет могат значително да увеличат
            времето за обработка. Прекомерното използване на JavaScript може да доведе до бавна
            реакция на страницата. Освен това, големите JavaScript файлове увеличават мрежовия
            трафик, което е проблем за потребители с ограничени интернет планове или при слаба
            връзка. С разнообразието от JavaScript рамки и библиотеки, проблемите с
            производителността стават все по-чести, особено когато кодът не е оптимизиран. Липсата
            на техники като lazy loading или code caching може да доведе до зареждане на неизползван
            код, който забавя цялостното представяне на уеб приложението. Друг фактор е блокиращият
            характер на JavaScript. Докато браузърът изтегля и изпълнява JavaScript, той спира
            обработката на други ресурси, като HTML и CSS, което може да забави зареждането на
            страницата. Ще разгледаме начини за оценка на JavaScript кода, неговото влияние върху
            зареждането на уеб страницата и как можем да го оптимизираме. Ще разгледаме инструменти
            за мониторинг на производителността, като Google Lighthouse, който може да помогне за
            идентифициране на проблеми и предлагане на решения за подобряване на ефективността на
            уеб страниците.
          </p>
          <figure>
            <img src="images/img1.webp" alt="Диаграма на производителността на JavaScript" />
            <figcaption>
              Илюстрация на влиянието на JavaScript върху времето за зареждане на страницата.
            </figcaption>
          </figure>
        </article>
      </section>

      <section id="js-cost">
        <h2>Цената на зареждането на JavaScript код</h2>
        <article class="content">
          <div class="js-impact">
            <h3>Въздействие на JavaScript върху потребителското изживяване</h3>
            <p>
              Когато браузърът зарежда уеб страница, той първо изтегля JavaScript файловете. Времето
              за трансфер може да варира значително в зависимост от скоростта на мрежата и размера
              на скриптовете. След това браузърът трябва да парсне и компилира тези скриптове —
              процеси, които натоварват процесора и могат да блокират основната нишка на изпълнение.
            </p>
            <p>
              Според тестове на <strong>CNN.com</strong>, дори на висок клас устройство като iPhone
              8, парсването и компилирането на около 1 MB JavaScript може да отнеме почти 4 секунди.
              На по-стари или по-слаби устройства този процес може да продължи до 13 секунди.
              Потребителите с по-слаби телефони обикновено изпитват 2 до 5 пъти по-дълги времена за
              обработка, което забавя момента, в който страницата става интерактивна.
            </p>
            <p>
              Ако един скрипт се изпълнява повече от 50 ms, това забавя цялостното време до
              интерактивност с цялата продължителност на изтегляне, парсване и изпълнение на
              скрипта.
            </p>
          </div>

          <div class="js-performance">
            <h3>Защо производителността на JavaScript е критична</h3>
            <p>
              JavaScript engines прекарват значително време при стартиране за парсване, компилиране
              и изпълнение на скриптовете. Тези етапи са решаващи за визуализиране и активиране на
              потребителския интерфейс.
            </p>
            <p>
              Ако тези процеси са бавни, потребителите може да виждат бутони и елементи, които
              визуално са налице, но не могат да бъдат кликнати или активни в продължение на няколко
              секунди. Това създава усещане за забиване на страницата, въпреки че тя изглежда
              заредена.
            </p>
          </div>

          <div class="js-devices">
            <h3>Разлики между устройства</h3>
            <p>
              На мобилни устройства — особено по-евтини или по-стари модели — времето за парсване и
              компилиране може да бъде 2 до 5 пъти по-дълго, отколкото на настолни компютри.
            </p>
            <p>
              Например, последен модел iPhone или Google Pixel може да зареди страницата почти
              моментално, докато по-стаар модел като Samsung Galaxy A20e ще има осезаемо забавяне.
            </p>
            <p>
              Поради това е важно при тестване да включваме представителен хардуер, а не само
              устройства от висок клас, за да осигурим добро потребителско изживяване за всички.
            </p>
          </div>
          <figure>
            <img
              src="images/img2.webp"
              alt="Времена за парсване и компилиране на JavaScript на различни устройства."
            />
            <figcaption>
              Времена за парсване и компилиране на JavaScript на различни устройства.
            </figcaption>
          </figure>
        </article>
      </section>

      <section id="js-measurement">
        <h2>Измерване на времето и ресурсите за парсване и компилиране на JavaScript код</h2>
        <p>
          Съществуват няколко инструмента и подхода, които могат да помогнат за измерване и анализ
          на тези процеси в реални условия.
        </p>

        <div class="tool chrome-devtools">
          <h3>Chrome DevTools</h3>
          <p>
            В <strong>Performance</strong> панела на <strong>Google DevTools</strong> можем да
            измерим времето, изразходвано за парсване и компилиране:
          </p>
          <ul>
            <li>
              <em>Bottom-Up</em>, <em>Call Tree</em>, или <em>Event Log</em> показват времето, което
              V8 прекарва в <code>Parse</code> и <code>Compile</code>.
            </li>
            <li>
              В <strong>Chrome Canary</strong> може да се активира
              <em>V8 Runtime Call Stats</em> чрез
              <em>Experiments > V8 Runtime Call Stats on Timeline</em>.
            </li>
          </ul>
          <figure>
            <img src="images/img3.webp" alt="Изглед от chrome-devtools" />
            <figcaption>Изглед от chrome-devtools</figcaption>
          </figure>
        </div>

        <div class="tool chrome-tracing">
          <h3>Chrome Tracing</h3>
          <p>
            Chrome Tracing е по-ниско ниво инструмент, който предоставя по-задълбочена информация.
            Записва подробно хронологията на събития и процеси в браузъра, като рендиране, скриптове
            и мрежова активност, и ги визуализира във времева линия. Това помага за откриване на
            проблеми с производителността, оптимизиране на използването на ресурси и подобряване на
            скоростта на приложенията.
          </p>
          <figure>
            <img src="images/img4.webp" alt="Изглед от chrome-tracing" />
            <figcaption>Изглед от chrome-tracing</figcaption>
          </figure>
        </div>

        <div class="tool wpt">
          <h3>WebPageTest</h3>
          <p>
            Измерва колко бързо се зареждат странците и идентифицира факторите, влияещи на
            скоростта. Предоставя подробни отчети с метрики като време за зареждане, време до първи
            байт и визуална прогресия, като може да симулира различни браузъри, устройства и мрежови
            условия.
          </p>
          <p>
            <strong>WebPageTest</strong> предоставя подробна информация при активирана опция
            <em>Chrome > Capture Dev Tools Timeline</em>
          </p>
          <p>Основни Функции</p>
          <ul>
            <li>
              <strong>Тестване от различни локации и устройства</strong> – избор между множество
              географски точки и браузъри, което позволява анализ на представянето в реални условия.
            </li>
            <li>
              <strong>Waterfall диаграми</strong> – Показват времевата линия на всички заявки,
              направени при зареждането на страницата (HTML, CSS, JS, изображения и др.)
            </li>
            <li>
              <strong>Видео и filmstrip</strong> – Представя визуално зареждането на сайта кадър по
              кадър.
            </li>
            <li>
              <strong>Core Web Vitals</strong> – поддръжка за метриките, които Google използва за
              оценка на потребителското изживяване.
            </li>
          </ul>
          <figure>
            <img src="images/img5.webp" alt="Изглед от WebPageTest" />
            <figcaption>Изглед от WebPageTest</figcaption>
          </figure>
        </div>

        <div class="tool user-timing">
          <h3>User Timing API</h3>
          <p>
            JavaScript API, което позволява измерване на производителността на уеб приложенията,
            като създава потребителски времеви timestamps и маркери. Помага за проследяване на
            специфични моменти от изпълнението на код, като началото и края на определени операции,
            и измерване на времето, което отнемат. Чрез методите <code>performance.mark()</code> и
            <code>performance.measure()</code> се събират точни данни за времето, които след това
            могат да се визуализират в инструменти за анализ, като Chrome DevTools.
          </p>
          <ul>
            <li>
              Скриптът трябва да е отделен, за да може измерването да започне преди неговото
              зареждане.
            </li>
            <li>
              Повторните зареждания могат да се повлияят от V8 <em>preparser</em>; това се избягва
              чрез добавяне на случаен низ към URL на скрипта.
            </li>
            <li>
              Може да се използва <strong>Google Analytics</strong> с персонализиран dimension за
              измерване на „parse“ време от реални потребители.
            </li>
          </ul>
          <figure>
            <img src="images/img6.png" alt="User Timing API" />
            <figcaption>Изглед от User Timing API</figcaption>
          </figure>
        </div>

        <div class="tool devicetiming">
          <h3>DeviceTiming (Etsy)</h3>
          <p>
            Инструментът <strong>DeviceTiming</strong> за измерване на производителността в
            контролирана среда, разработен от Etsy, събира данни с висока точност за това колко
            бързо се зареждат и визуализират страниците на устройствата на потребителите. Метрики за
            клиентската страна (като например кога се появява основното съдържание) – помага за
            откриване на забавяния при различни устройства и оптимизиране скоростта на сайта според
            реалното потребителско изживяване.
          </p>

          <ul>
            <li>Работи чрез обвиване на скриптове с инструментален код.</li>
            <li>
              Позволява сравнение на поведение между устройства като лаптопи, телефони и таблети.
            </li>
            <li>
              Описан подробно в статията на Daniel Espeset –
              <em>Benchmarking JS Parsing and Execution on Mobile Devices</em>.
            </li>
          </ul>
          <figure>
            <img src="images/img7.webp" alt="Изглед от DeviceTiming" />
            <figcaption>Изглед от DeviceTiming</figcaption>
          </figure>
        </div>
      </section>

      <section id="networking">
        <h2>Влияние на мрежовия трафик</h2>
        <p>
          Съществуват няколко инструмента и подхода, които могат да помогнат за измерване и анализ
          на JavaScript парсването и компилирането в реални условия. Дългите задачи, причинени от
          големи JavaScript пакети, могат да блокират основния поток на браузъра за повече от 50
          милисекунди. Това води до забавяне на отговора на потребителските действия.
        </p>

        <div class="chrome-network-proritization">
          <h3>Chrome's network prioritisation</h3>
          <p><strong>Скриптове</strong></p>
          <ul>
            <li>
              Блокиращи скриптове (без <code>async</code> или <code>defer</code>): заявяват се преди
              първото изображение, получават среден приоритет.
            </li>
            <li>
              Ако същите скриптове ce заявят след първото изображение, те ce третират c нисък
              приоритет
            </li>
            <li>
              Скриптовете, заредени c <code>async, defer</code> или чрез чрез
              <code>document.createElement</code> винаги получават най-нисък приоритет, независимо
              от тяхната позиция в документа.
            </li>
          </ul>
          <p><strong>Предварително заредени ресурси (Preload)</strong></p>
          <ul>
            <li>
              Предварително заредените ресурси получават висок приоритет, независимо от позицията им
              в документа.
            </li>
            <li>
              Предварително заредените ресурси, които не са блокиращи, получават най-нисък приоритет
              (Net:Lowest).
            </li>
            <li>
              Когато preload използва атрибута <code>as</code>, приоритетът съответства на типа
              <code>ресурс</code> :<br />
              <code>as="style"</code> – най-висок приоритет <br />
              <code>as="script"</code> – среден до нисък приоритет.
            </li>
          </ul>
          <figure>
            <img src="images/img8.webp" alt="DevTools priorities mapping" />
            <figcaption>DevTools priorities mapping</figcaption>
          </figure>

          <div class="tool tools-testing">
            <h3>Оценка на производителността на JavaScript в мрежовия трафик</h3>
            <ul>
              <li>
                <strong>Мрежов панел (Network Panel):</strong> Анализира размера и времето за
                зареждане на всеки ресурс, идентифицира тесни места и наблюдава реда на зареждане на
                скриптовете.
              </li>
              <li>
                <strong>Панел за производителност (Performance Panel):</strong> Записва и инспектира
                времевата линия на изпълнение на скриптове – помага за откриване на блокиращи
                процеси
              </li>
            </ul>
            <p>
              Инструменти като Lighthouse и WebPageTest предоставят метрики за производителност:
            </p>
            <ul>
              <li>
                <strong>Time to First Byte (TTFB)</strong> Времето от изпращането на заявката до
                получаването на първия байт от отговора. Показва колко бързо сървърът започва да
                отговаря. Високите стойности на TTFB могат да забавят зареждането на JavaScript и
                другите ресурси
              </li>
              <li>
                <strong>First Contentful Paint (FCP)</strong> Моментът, в който първият видим
                елемент (текст, изображение и т.н.) се появява на екрана. Показва кога потребителят
                вижда първото визуално съдържание. JavaScript, който блокира рендирането, може да
                забави FCP.
              </li>
              <li>
                <strong>Total Blocking Time (TBT)</strong> Общото време, през което основният поток
                е блокиран от дълги JavaScript задачи (над 50 ms). Високият TBT показва, че
                JavaScript блокира основния поток
              </li>
              <li>Други.</li>
            </ul>
          </div>
        </div>
      </section>

      <section id="optimizations">
        <h2>Методи за оптимизиране</h2>

        <article id="caching">
          <section id="js-code-caching">
            <h2>Code Caching: по-бързо зареждане чрез избягване на компилиране</h2>
            <article class="content">
              <p>
                Механизъм за съхранение на локално копие на компилиран JavaScript код. Целта е да се
                избегнат скъпите операции като изтегляне, парсване и компилиране при последващи
                посещения на уеб страницата. В началото този механизъм позволява да се пропуска
                приблизително <strong>45% от времето за компилация</strong> при вторични зареждания.
              </p>

              <h3>Как работи кеширането на код?</h3>
              <p>
                В някои платформи като Google V8 — кеширането се активира за скриптове или Service
                Worker скриптове, които се изпълняват
                <strong>два пъти в рамките на 72 часа</strong>.<br />
                За скриптове, съхранени в Cache Storage чрез Service Worker — кеширането се активира
                при <strong>първото изпълнение</strong>.
              </p>
              <p>
                Aко кодът подлежи на кеширане, V8 ще <strong>пропусне</strong> парсването и
                компилирането при третото зареждане, което значително ускорява зареждането на
                страницата.
              </p>

              <h3>Детайли и инструменти</h3>
              <p>
                За по-задълбочен се използват експерименталните опции в
                <code>chrome://flags/#v8-cache-strategies-for-cache-storage</code> за наблюдаване на
                разликите в поведението при кеширане.
              </p>
              <p>
                Флагът в Chrome
                <code>--js-flags=--profile-deserialization</code>, показва дали даден скрипт се
                зарежда директно от кеша — това се визуализира като
                <strong>"deserialization events"</strong> в Chrome Tracing логовете.
              </p>

              <h3>Ограничения и особености</h3>
              <p>
                <strong>Само eagerly compiled код</strong> се кешира. Това включва главния код,
                който се изпълнява веднъж за инициализация на глобални стойности.
              </p>
              <p>
                Функции, които се дефинират но не се извикват веднага, обикновено се компилират
                <em>lazy</em> и не винаги се кешират. За сметка на това,
                <strong>IIFE</strong> (Immediately Invoked Function Expressions), които са често
                използвани в инструменти като <code>optimize-js</code>, се включват в кеша, тъй като
                се компилират веднага.
              </p>
            </article>
          </section>
        </article>

        <article id="streaming">
          <section id="js-script-streaming">
            <h2>Script Streaming - ускорено парсване чрез фонови нишки (background threads)</h2>
            <article class="content">
              <p>
                Script streaming позволява парсването на <code>async</code> и
                <code>defer</code> скриптове да се извършва на фонови нишки, още докато се изтеглят.
                Това подобрява времето за зареждане на страницата с до 10% спрямо различни
                източници. Тази оптимизация вече се прилага и за
                <strong>синхронни скриптове</strong>, които обикновено блокират парсването на HTML.
              </p>

              <p>
                Откакто функцията беше въведена <strong>V8</strong> премина към позволяване на
                всички скриптове, дори блокиращите <code>&lt;script src=""&gt;</code> — да бъдат
                парсвани на фонови нишки. Това води до значителни подобрения в производителността.
              </p>

              <h3>Ограничения и най-добри практики</h3>
              <p>
                Има само <strong>една нишка за парсване</strong> чрез стрийминг, така че е важно
                големите или критични скриптове да се поставят първи — така те ще бъдат хванати от
                механизма. <br />
                Добра практика е да се използва
                <code>&lt;script defer&gt;</code> в <code>&lt;head&gt;</code>, за да позволим ранно
                откриване и парсване на скрипта във фонов режим.
              </p>

              <h3>Измерване на ползите</h3>
              <p>
                Чрез панела <strong>Performance</strong> в <strong>Chrome DevTools</strong> можем да
                проверим дали дадени скриптове се парсват чрез стрийминг. Ако един скрипт доминира
                времето за парсване, той трябва да се възползва от механизма за фоново парсване.
              </p>
              <figure>
                <img src="images/img9.webp" alt="" />
                <figcaption></figcaption>
              </figure>
            </article>
          </section>
        </article>

        <article id="recompilation">
          <section id="js-precompilation">
            <h2>Предварителна компилация на JavaScript (Ahead Of Time)</h2>
            <p>
              Подход за оптимизиране на производителността на уеб приложения чрез трансформиране на
              изходния код в машинен код преди изпълнение. AOT компилацията елиминира необходимостта
              от интерпретиране на кода в браузъра, което води до значително по-бързо стартиране на
              приложенията. Тъй като AOT компилираният код не изисква наличието на JavaScript
              интерпретатор по време на изпълнение, това води до по-ниска консумация на памет.
            </p>
            <p>
              Предварителната компилация затруднява reversee engineering и намалява риска от атаки,
              тъй като компонентите се компилират в JavaScript файлове преди да бъдат предоставени
              на клиента.<br />
              Тъй като кодът е компилиран предварително, изпълнението му е по-предвидимо и стабилно,
              без неочаквани паузи или забавяния, характерни за JIT компилацията.
            </p>

            <p>
              <strong>Недостатъци: </strong>Размер на байткода — Предварително компилирани скриптове
              често са по-големи от оригиналния JavaScript, което може да удължи времето за
              изтегляне и зареждане.
            </p>
          </section>
          <figure>
            <img src="images/img10.png" alt="" />
            <figcaption></figcaption>
          </figure>
        </article>
      </section>
    </main>

    <footer id="resources">
      <h2>Източници</h2>
      <div class="source-columns">
        <div class="source-group">
          <h3>Основни</h3>
          <ul class="source-list">
            <li>
              <a
                href="https://medium.com/dev-channel/the-cost-of-javascript-84009f51e99e"
                target="_blank"
                rel="noopener"
              >
                Addy Osmani, "The Cost of JavaScript", публикуван на Nov 15-11-2017
              </a>
            </li>
            <li>
              <a
                href="https://medium.com/reloading/javascript-start-up-performance-69200f43b201"
                target="_blank"
                >Addy Osmani, "JavaScript Start-up Performance", публикуван на 09-02-2017</a
              >
            </li>
            <li>
              <a href="https://web.dev/articles/apply-instant-loading-with-prpl" target="_blank"
                >Houssein Djirdeh, "Apply Instant Loading with PRPL", актуализиран на 05-11-2018
              </a>
            </li>
          </ul>
        </div>

        <div class="source-group">
          <h3>Второстепенни</h3>
          <ul class="source-list">
            <li>
              <a
                href="https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Performance/JavaScript"
                target="_blank"
                >MDN: JS Performance</a
              >
            </li>
            <li>
              <a
                href="https://medium.com/reloading/preload-prefetch-and-priorities-in-chrome-776165961bbf"
                target="_blank"
              >
                Addy Osmani, "Preload, Prefetch and Priorities in Chrome", 27-03-2017</a
              >
            </li>
            <li>
              <a href="https://web.dev/articles/fcp" target="_blank"
                >First Contentful Paint (FCP)</a
              >
            </li>
            <li>
              <a href="https://web.dev/articles/tbt" target="_blank">Total Blocking Time (TBT)</a>
            </li>
            <li>
              <a href="https://web.dev/articles/ttfb" target="_blank">Time to First Byte (TTFB)</a>
            </li>
          </ul>
        </div>
      </div>
    </footer>

    <script src="javascript/script.js"></script>
  </body>
</html>
